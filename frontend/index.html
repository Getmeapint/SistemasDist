<!DOCTYPE html>
<html>
<head>
    <title>Trail Running Visualization</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/1.5.1/gpx.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <style>
        body {
            margin: 0;
            font-family: sans-serif;
        }
        #map {
            height: 100vh;
            width: 100%;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
        }
        select {
            padding: 5px;
            border-radius: 5px;
        }
        #leaderboard {
            margin-top: 10px;
            max-height: 300px;
            overflow: auto;
            width: 220px;
        }
        #leaderboard h4 { margin: 6px 0; }
        #leaderboardList { padding-left: 18px; margin: 0; }
    </style>
</head>
<body>
    <div id="controls">
        <label for="raceSelect">Select Race:</label>
        <select id="raceSelect">
            <option value="all" selected>All Races</option>
            <option value="race-trail_route_1">Trail Route 1</option>
            <option value="race-trail_route_2">Trail Route 2</option>
            <option value="race-trail_route_3">Trail Route 3</option>
            <option value="race-trail_route_4">Trail Route 4</option>
        </select>
        <div id="leaderboard">
            <h4>Leaderboard</h4>
            <ol id="leaderboardList"></ol>
        </div>
    </div>

    <div id="map"></div>

    <script>
        // Initialize map
        const map = L.map('map').setView([0, 0], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);

        // Initialize global route features object FIRST
        window.raceLineFeatures = {};

        // Icons
        const maleIcon = L.icon({
            iconUrl: "/male.png",
            iconSize: [28, 65],
            iconAnchor: [12, 64],
            popupAnchor: [-3, -46]
        });
        const femaleIcon = L.icon({
            iconUrl: "/female.png",
            iconSize: [28, 65],
            iconAnchor: [12, 64],
            popupAnchor: [-3, -46]
        });

        // Avoid Leaflet trying to load default shadow images like /pin-shadow.png
        if (L && L.Icon && L.Icon.Default && L.Icon.Default.mergeOptions) {
            L.Icon.Default.mergeOptions({ shadowUrl: '' });
        }

        // Athlete state
        const athleteMarkers = {};
        const athleteData = {};  // stores last known position for leaderboard logic

        // Remove all current markers and reset athlete state (used when switching races)
        function clearMarkers() {
            Object.keys(athleteMarkers).forEach(name => {
                try { map.removeLayer(athleteMarkers[name]); } catch (e) {}
            });
            // reset
            for (const k of Object.keys(athleteMarkers)) delete athleteMarkers[k];
            for (const k of Object.keys(athleteData)) delete athleteData[k];
            // clear leaderboard
            const lb = document.getElementById('leaderboardList');
            if (lb) lb.innerHTML = '';
        }

    // Route points extracted from the loaded GPX (array of [lat, lng])
    let routePoints = [];

        // GPX layer management
        // Support multiple GPX layers (one per race) so 'All Races' can show all tracks
        const gpxLayers = {}; // map: raceTopic -> L.GPX layer
        const raceRoutePoints = {}; // map: raceTopic -> array of route points
        const raceCumulativeDistances = {}; // map: raceTopic -> cumulative distances (km) for each point

        // Simple color palette to distinguish races
        const COLOR_PALETTE = [
            '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b',
            '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'
        ];

        function getColorForRace(raceTopic) {
            // deterministic index from raceTopic string
            let h = 0;
            for (let i = 0; i < raceTopic.length; i++) h = (h * 31 + raceTopic.charCodeAt(i)) >>> 0;
            return COLOR_PALETTE[h % COLOR_PALETTE.length];
        }

        function clearGpxLayers() {
            Object.keys(gpxLayers).forEach(k => {
                try { map.removeLayer(gpxLayers[k]); } catch (e) {}
                delete gpxLayers[k];
            });
            Object.keys(raceRoutePoints).forEach(k => delete raceRoutePoints[k]);
            Object.keys(raceCumulativeDistances).forEach(k => delete raceCumulativeDistances[k]);
            routePoints = [];
        }

        // routePoints remains the points for the currently visible single GPX (used by leaderboard)
        let gpxLastLoadedRace = null;

        function loadGPX(routeFile, raceTopic, color) {
            // remove existing layer for this race if present
            if (gpxLayers[raceTopic]) {
                try { map.removeLayer(gpxLayers[raceTopic]); } catch (e) {}
                delete gpxLayers[raceTopic];
            }

            const options = {
                async: true,
                marker_options: {
                    startIconUrl: "start.png",
                    endIconUrl: "finish.png",
                    shadowUrl: "" // prevent requests to missing pin-shadow.png
                },
                polyline_options: {
                    color: color || getColorForRace(raceTopic),
                    weight: 4,
                    opacity: 0.8
                }
            };

            const layer = new L.GPX(routeFile, options).on('loaded', function(e) {
                // Extract polyline points for this race and store per-race
                let points = [];
                try {
                    console.log(`GPX loaded for ${raceTopic}`);

                    // Preferred: convert the loaded GPX layer to GeoJSON and read the line geometry
                    const gj = (e.target && typeof e.target.toGeoJSON === 'function') ? e.target.toGeoJSON() : null;
                    if (gj) {
                        const features = Array.isArray(gj.features) ? gj.features : (gj.type === 'Feature' ? [gj] : []);
                        features.forEach(f => {
                            if (!f.geometry) return;
                            const { type, coordinates } = f.geometry;
                            if (type === 'LineString' && Array.isArray(coordinates)) {
                                coordinates.forEach(coord => {
                                    if (Array.isArray(coord) && coord.length >= 2) {
                                        points.push([coord[1], coord[0]]);
                                    }
                                });
                            } else if (type === 'MultiLineString' && Array.isArray(coordinates)) {
                                coordinates.forEach(line => {
                                    if (Array.isArray(line)) {
                                        line.forEach(coord => {
                                            if (Array.isArray(coord) && coord.length >= 2) {
                                                points.push([coord[1], coord[0]]);
                                            }
                                        });
                                    }
                                });
                            }
                        });
                        if (points.length > 0) {
                            console.log(`  Extracted ${points.length} points via toGeoJSON()`);
                        }
                    }
                    
                    // Try direct getLatLngs on the GPX layer
                    if (points.length === 0 && e.target && typeof e.target.getLatLngs === 'function') {
                        const latlngs = e.target.getLatLngs();
                        console.log(`  Got ${latlngs.length} points from getLatLngs()`);
                        if (Array.isArray(latlngs)) {
                            latlngs.forEach(function(item) {
                                if (item && item.lat !== undefined && item.lng !== undefined) {
                                    points.push([item.lat, item.lng]);
                                }
                            });
                        }
                    }
                    
                    // Try accessing _layers property directly if getLatLngs didn't work
                    if (points.length === 0 && e.target && e.target._layers) {
                        console.log('  Trying _layers property...');
                        Object.keys(e.target._layers).forEach(function(key) {
                            const layer = e.target._layers[key];
                            console.log(`    Layer ${key}:`, layer.constructor.name, `has getLatLngs:`, typeof layer.getLatLngs);
                            if (typeof layer.getLatLngs === 'function') {
                                try {
                                    const latlngs = layer.getLatLngs();
                                    console.log(`      Got ${latlngs.length} points`);
                                    latlngs.forEach(function(item) {
                                        if (item && item.lat !== undefined && item.lng !== undefined) {
                                            points.push([item.lat, item.lng]);
                                        }
                                    });
                                } catch (err) {
                                    console.log(`      Error getting points:`, err.message);
                                }
                            }
                        });
                    }
                    
                } catch (err) {
                    console.warn('Could not extract route points:', err);
                }
                raceRoutePoints[raceTopic] = points;
                console.log(`Result: Loaded ${points.length} points for ${raceTopic}`);
                
                // Only create lineString if we have valid points (at least 2)
                if (points.length < 2) {
                    console.warn(`Route ${raceTopic} has insufficient points (${points.length}), skipping distance calculations`);
                    window.raceLineFeatures[raceTopic] = null;
                    return;
                }
                
                // Create a GeoJSON LineString from the points for use with turf.js
                // Turf uses [lon, lat] order, not [lat, lon]
                const lineCoords = points.map(p => [p[1], p[0]]);
                let routeLine;
                try {
                    routeLine = turf.lineString(lineCoords);
                } catch (err) {
                    console.error(`Failed to create lineString for ${raceTopic}:`, err);
                    window.raceLineFeatures[raceTopic] = null;
                    return;
                }
                
                // Store the line feature for distance calculations
                if (!window.raceLineFeatures) window.raceLineFeatures = {};
                window.raceLineFeatures[raceTopic] = routeLine;
                
                // Calculate total distance in km
                const totalDistanceKm = turf.length(routeLine, { units: 'kilometers' });
                console.log(`${raceTopic}: Total distance = ${totalDistanceKm.toFixed(2)}km`);
                
                // Pre-calculate cumulative distances at each point for reference
                const cumulativeDistances = [0];
                for (let i = 1; i < points.length; i++) {
                    const segmentLine = turf.lineString([lineCoords[i-1], lineCoords[i]]);
                    const segmentDistKm = turf.length(segmentLine, { units: 'kilometers' });
                    cumulativeDistances.push(cumulativeDistances[cumulativeDistances.length - 1] + segmentDistKm);
                }
                raceCumulativeDistances[raceTopic] = cumulativeDistances;
                
                // Also set global routePoints for single-race view
                routePoints = points;
                
                // Fit bounds for the first race or for single-race views
                try {
                    map.fitBounds(e.target.getBounds());
                } catch (err) {}
            }).addTo(map);

            gpxLayers[raceTopic] = layer;
            gpxLastLoadedRace = raceTopic;
            return layer;
        }

        // --- WebSocket Handling (supports multiple sockets for 'All Races') ---
        const sockets = {}; // map: topic -> WebSocket

        function connectWebSocket(raceTopic) {
            // avoid duplicate
            if (sockets[raceTopic]) return;

            // Use window.location.hostname to connect to backend; in Docker it resolves to service name, locally to localhost
            // When running locally via port-forward use 8000; adjust if you expose a different port
            const wsUrl = `ws://${window.location.hostname}:30015/ws?race=${raceTopic}`;
            const ws = new WebSocket(wsUrl);
            sockets[raceTopic] = ws;
            //nerd

            ws.onopen = () => console.log(`Connected to ${raceTopic}`);
            ws.onclose = () => {
                console.log(`Disconnected from ${raceTopic}`);
                delete sockets[raceTopic];
            };
            ws.onerror = err => console.error("WebSocket error:", err);

            ws.onmessage = event => {
                const data = JSON.parse(event.data);
                const athlete = data.athlete;
                const gender = data.gender;
                const lat = data.location.latitude;
                const lon = data.location.longitude;
                const race = data.race || raceTopic;

                const icon = gender === "male" ? maleIcon : femaleIcon;

                athleteData[athlete] = { lat, lon, race, gender };

                if (athleteMarkers[athlete]) {
                    athleteMarkers[athlete].setLatLng([lat, lon]);
                } else {
                    const marker = L.marker([lat, lon], {icon: icon})
                        .addTo(map)
                        .bindPopup(`<b>${athlete}</b><br>${race}`);
                    athleteMarkers[athlete] = marker;
                }

                // Update leaderboard immediately when new position arrives
                updateLeaderboard();
            };
        }

        function closeAllSockets() {
            Object.keys(sockets).forEach(topic => {
                try { sockets[topic].close(); } catch (e) {}
                delete sockets[topic];
            });
        }

                // Compute distance along route for a given lat/lon using the athlete's race route
                function nearestRouteIndex(lat, lon, raceTopicForAthlete) {
                    const routeLine = window.raceLineFeatures && window.raceLineFeatures[raceTopicForAthlete];
                    const points = raceRoutePoints[raceTopicForAthlete] || [];
                    
                    if (!routeLine || points.length === 0) {
                        console.warn(`nearestRouteIndex: No route found for ${raceTopicForAthlete}. Available routes:`, window.raceLineFeatures ? Object.keys(window.raceLineFeatures) : 'none');
                        return { index: -1, distance: 0, totalDistance: 0 };
                    }
                    
                    // Create a point feature from athlete position [lon, lat] for turf
                    const athletePoint = turf.point([lon, lat]);
                    
                    // Find the closest point on the route line (allows tolerance off path)
                    const snappedPoint = turf.nearestPointOnLine(routeLine, athletePoint);
                    const segmentIndex = snappedPoint.properties.index || 0;
                    
                    // Convert points to [lon, lat] for turf
                    const lineCoords = points.map(p => [p[1], p[0]]);
                    
                    // Calculate distance from start to this segment
                    let distanceToSegmentStart = 0;
                    if (segmentIndex > 0) {
                        const segmentStartLine = turf.lineString(lineCoords.slice(0, segmentIndex + 1));
                        distanceToSegmentStart = turf.length(segmentStartLine, { units: 'kilometers' });
                    }
                    
                    // Calculate distance along the segment from segment start to snapped point
                    const segmentStart = turf.point(lineCoords[segmentIndex]);
                    const distAlongSegment = turf.distance(segmentStart, snappedPoint, { units: 'kilometers' });
                    
                    // Total distance along route
                    const distanceAlongRoute = distanceToSegmentStart + distAlongSegment;
                    
                    // Get total route distance
                    const totalDistance = turf.length(routeLine, { units: 'kilometers' });
                    
                    return { 
                        index: segmentIndex, 
                        distance: distanceAlongRoute,
                        totalDistance: totalDistance
                    };
                }

                // Update leaderboard DOM by sorting athletes by progress within their own race
                function updateLeaderboard() {
                    const list = document.getElementById('leaderboardList');
                    if (!list) return;
                    
                    // Build array of {name, progress, race, distance}
                    const entries = Object.keys(athleteData).map(name => {
                        const a = athleteData[name];
                        const result = nearestRouteIndex(a.lat, a.lon, a.race);
                        
                        // result is now an object with { index, distance, totalDistance }
                        let athleteDistance = 0;
                        let totalDistance = 0;
                        
                        if (typeof result === 'object' && result !== null) {
                            athleteDistance = result.distance || 0;
                            totalDistance = result.totalDistance || 0;
                        }
                        
                        const progress = totalDistance > 0 ? (athleteDistance / totalDistance) * 100 : 0;
                        if (athleteDistance > 0) {
                            console.log(`${name} (${a.race}): ${athleteDistance.toFixed(2)}km / ${totalDistance.toFixed(2)}km total`);
                        }
                        return { name, progress, race: a.race, distance: athleteDistance };
                    });
                    
                    // Group by race and sort within each race
                    const byRace = {};
                    entries.forEach(e => {
                        if (!byRace[e.race]) byRace[e.race] = [];
                        byRace[e.race].push(e);
                    });
                    
                    // Sort each race's athletes by distance (descending)
                    Object.keys(byRace).forEach(race => {
                        byRace[race].sort((a, b) => b.distance - a.distance);
                    });
                    
                    // Build HTML with per-race rankings showing distance
                    list.innerHTML = '';
                    Object.keys(byRace).sort().forEach(race => {
                        byRace[race].forEach((e, position) => {
                            const li = document.createElement('li');
                            const raceName = race.replace('race-', '');
                            li.textContent = `${raceName}: ${position + 1}. ${e.name} (${e.distance.toFixed(2)}km / ${Math.round(e.progress)}%)`;
                            list.appendChild(li);
                        });
                    });
                }

                // Periodically refresh leaderboard in case of gaps
                setInterval(updateLeaderboard, 1000);

        // --- Race selection ---
        const raceSelect = document.getElementById("raceSelect");
        function raceToGpxFile(selectedRace) {
            // Map a topic/race name to an existing GPX file under /gpx
            // If the selectedRace looks like 'race-<name>' we use that name.
            if (!selectedRace) return 'gpx/trail_route_1.gpx';
            if (selectedRace.startsWith('race-')) {
                return `gpx/${selectedRace.replace('race-', '')}.gpx`;
            }
            // Known non-race topics -> map to a default GPX
            const FALLBACK_MAP = {
                'runner-events': 'gpx/trail_route_1.gpx'
            };
            return FALLBACK_MAP[selectedRace] || 'gpx/trail_route_1.gpx';
        }

        raceSelect.addEventListener("change", (e) => {
            const selectedRace = e.target.value;
            console.log("Switching to race:", selectedRace);
            // Clear existing markers and leaderboard when switching races
            clearMarkers();

            // Close any existing sockets first
            closeAllSockets();

            if (selectedRace === 'all') {
                // Open a single WebSocket with race=all parameter; backend broadcasts all runners
                clearGpxLayers();
                connectWebSocket('all');
                
                // Load all race GPX files for visualization
                const raceOptions = [];
                for (const opt of raceSelect.options) {
                    const v = opt.value;
                    if (v && v.startsWith('race-')) {
                        raceOptions.push(v);
                    }
                }
                for (let i = 0; i < raceOptions.length; i++) {
                    const v = raceOptions[i];
                    const gpxFile = raceToGpxFile(v);
                    loadGPX(gpxFile, v, getColorForRace(v));
                }
                return;
            }

            connectWebSocket(selectedRace);

            // Load corresponding GPX (map non-race topics to a default GPX)
            clearGpxLayers();
            const gpxFile = raceToGpxFile(selectedRace);
            loadGPX(gpxFile, selectedRace, getColorForRace(selectedRace));
        });

        // Initialize first connection using the current select value
        const initialRace = raceSelect.value;
        if (initialRace === 'all') {
            // connect with race=all (single connection; backend broadcasts all)
            clearGpxLayers();
            connectWebSocket('all');
            
            // Load all race GPX layers
            const raceOptions = [];
            for (const opt of raceSelect.options) {
                const v = opt.value;
                if (v && v.startsWith('race-')) raceOptions.push(v);
            }
            for (const v of raceOptions) {
                const gpxFile = raceToGpxFile(v);
                loadGPX(gpxFile, v, getColorForRace(v));
            }
        } else {
            connectWebSocket(initialRace);
            loadGPX(raceToGpxFile(initialRace), initialRace, getColorForRace(initialRace));
        }
    </script>
</body>
</html>
