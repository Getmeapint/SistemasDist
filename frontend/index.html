<!DOCTYPE html>
<html>
<head>
    <title>Trail Running Visualization</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/1.5.1/gpx.min.js"></script>
    <style>
        body {
            margin: 0;
            font-family: sans-serif;
        }
        #map {
            height: 100vh;
            width: 100%;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
        }
        select {
            padding: 5px;
            border-radius: 5px;
        }
        #leaderboard {
            margin-top: 10px;
            max-height: 300px;
            overflow: auto;
            width: 220px;
        }
        #leaderboard h4 { margin: 6px 0; }
        #leaderboardList { padding-left: 18px; margin: 0; }
    </style>
</head>
<body>
    <div id="controls">
        <label for="topicSelect">Select Trail:</label>
        <select id="topicSelect">
            <option value="runner-events">Default Trail</option>
            <option value="all">All Trails</option>
            <option value="trail_route_1">Trail Route 1</option>
            <option value="trail_route_2">Trail Route 2</option>
            <option value="trail_route_3">Trail Route 3</option>
            <option value="trail_route_4">Trail Route 4</option>
        </select>
        <div id="leaderboard">
            <h4>Leaderboard</h4>
            <ol id="leaderboardList"></ol>
        </div>
    </div>

    <div id="map"></div>

    <script>
        // Initialize map
        const map = L.map('map').setView([0, 0], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '© OpenStreetMap contributors'
        }).addTo(map);

        // Icons
        const maleIcon = L.icon({
            iconUrl: "assets/images/male.png",
            iconSize: [28, 65],
            iconAnchor: [12, 64],
            popupAnchor: [-3, -46]
        });
        const femaleIcon = L.icon({
            iconUrl: "assets/images/female.png",
            iconSize: [28, 65],
            iconAnchor: [12, 64],
            popupAnchor: [-3, -46]
        });

        // Avoid Leaflet trying to load default shadow images like /pin-shadow.png
        if (L && L.Icon && L.Icon.Default && L.Icon.Default.mergeOptions) {
            L.Icon.Default.mergeOptions({ shadowUrl: '' });
        }

        // Athlete state
        const athleteMarkers = {};
        const athleteData = {};  // stores last known position for leaderboard logic

        // Remove all current markers and reset athlete state (used when switching topics)
        function clearMarkers() {
            Object.keys(athleteMarkers).forEach(name => {
                try { map.removeLayer(athleteMarkers[name]); } catch (e) {}
            });
            // reset
            for (const k of Object.keys(athleteMarkers)) delete athleteMarkers[k];
            for (const k of Object.keys(athleteData)) delete athleteData[k];
            // clear leaderboard
            const lb = document.getElementById('leaderboardList');
            if (lb) lb.innerHTML = '';
        }

    // Route points extracted from the loaded GPX (array of [lat, lng])
    let routePoints = [];

        // GPX layer management
        // Support multiple GPX layers (one per topic) so 'All Trails' can show all tracks
        const gpxLayers = {}; // map: topic -> L.GPX layer    // Simple color palette to distinguish topics
    const COLOR_PALETTE = [
        '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b',
        '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'
    ];

    function getColorForTopic(topic) {
        // deterministic index from topic string
        let h = 0;
        for (let i = 0; i < topic.length; i++) h = (h * 31 + topic.charCodeAt(i)) >>> 0;
        return COLOR_PALETTE[h % COLOR_PALETTE.length];
    }        function clearGpxLayers() {
            Object.keys(gpxLayers).forEach(k => {
                try { map.removeLayer(gpxLayers[k]); } catch (e) {}
                delete gpxLayers[k];
            });
            routePoints = [];
        }

    // routePoints remains the points for the currently visible single GPX (used by leaderboard)
    let gpxLastLoadedTopic = null;

    function loadGPX(routeFile, topic, color) {
        // remove existing layer for this topic if present
        if (gpxLayers[topic]) {
            try { map.removeLayer(gpxLayers[topic]); } catch (e) {}
            delete gpxLayers[topic];
        }                const options = {
                async: true,
                marker_options: {
                    startIconUrl: "assets/images/start.png",
                    endIconUrl: "assets/images/finish.png",
                },
                polyline_options: {
                    color: color || getColorForTopic(topic),
                    weight: 4,
                    opacity: 0.8
                }
            };

            const layer = new L.GPX(routeFile, options).on('loaded', function(e) {
                // If this is the last explicitly loaded GPX (single topic view), fit bounds and extract routePoints
                if (!gpxLastLoadedTopic || gpxLastLoadedTopic === topic) {
                    try {
                        map.fitBounds(e.target.getBounds());
                    } catch (err) {}

                    // Extract polyline points for leaderboard/progress calculation
                    routePoints = [];
                    try {
                        const layers = e.target.getLayers ? e.target.getLayers() : [];
                        layers.forEach(function(layer) {
                            if (layer instanceof L.Polyline) {
                                const latlngs = layer.getLatLngs();
                                latlngs.forEach(function(item) {
                                    if (Array.isArray(item)) {
                                        item.forEach(function(p) { routePoints.push([p.lat, p.lng]); });
                                    } else {
                                        routePoints.push([item.lat, item.lng]);
                                    }
                                });
                            }
                        });
                    } catch (err) {
                        console.warn('Could not extract route points for leaderboard:', err);
                    }
            }
        }).addTo(map);

        gpxLayers[topic] = layer;
        gpxLastLoadedTopic = topic;
        return layer;
    }        // --- WebSocket Handling (supports multiple sockets for 'All Trails') ---
    const sockets = {}; // map: topic -> WebSocket
    const connectionIds = {}; // map: topic -> current conn_id (from backend)

        function connectWebSocket(topic) {
            // avoid duplicate
            if (sockets[topic]) return;

            // const wsUrl = `ws://backend-service:8000/ws?topic=${topic}`;
            const wsUrl = `ws://127.0.0.1:8000/ws?topic=${topic}`;
            const ws = new WebSocket(wsUrl);
            // store the socket in the mapping immediately
            sockets[topic] = ws;
            // reserve a slot for the connection id; will be set when backend sends the first message
            connectionIds[topic] = null;
            // tag the socket so messages can verify they're from the active socket
            ws._topic = topic;

            ws.onopen = () => console.log(`Connected to ${topic}`);
            ws.onclose = () => {
                console.log(`Disconnected from ${topic}`);
                delete sockets[topic];
                try { delete connectionIds[topic]; } catch (e) {}
            };
            ws.onerror = err => console.error("WebSocket error:", err);

            ws.onmessage = event => {
                // Ignore messages from sockets that are no longer the active socket for this topic
                if (sockets[topic] !== ws) return;

            let data;
            try { data = JSON.parse(event.data); } catch (err) { return; }

            // If backend attaches a conn_id, ensure it matches the current active conn_id for this topic.
            // If we haven't established the connectionIds[topic] yet (null), set it from the first message.
            if (data && data.conn_id) {
                if (connectionIds[topic] == null) {
                    connectionIds[topic] = data.conn_id;
                    // also tag the socket for debugging
                    try { ws._connId = data.conn_id; } catch (e) {}
                } else if (connectionIds[topic] !== data.conn_id) {
                    // message is from a stale/other connection — ignore
                    return;
                }
            }
            const athlete = data.athlete;
            const gender = data.gender;
            const lat = data.location && data.location.latitude;
            const lon = data.location && data.location.longitude;
            const athleteTopic = data.topic || topic;

                if (typeof lat !== 'number' || typeof lon !== 'number') return;

                const icon = gender === "male" ? maleIcon : femaleIcon;

                athleteData[athlete] = { lat, lon, topic: athleteTopic, gender };

                if (athleteMarkers[athlete]) {
                    try { athleteMarkers[athlete].setLatLng([lat, lon]); } catch (e) {}
                } else {
                    const marker = L.marker([lat, lon], {icon: icon})
                        .addTo(map)
                        .bindPopup(`<b>${athlete}</b><br>${athleteTopic}`);
                    athleteMarkers[athlete] = marker;
                }

                // Update leaderboard immediately when new position arrives
                updateLeaderboard();
            };
        }

        function closeAllSockets() {
            Object.keys(sockets).forEach(topic => {
                try {
                    const s = sockets[topic];
                    if (s) {
                        // disable handlers to reduce chance of in-flight messages being processed
                        try { s.onmessage = () => {}; } catch (e) {}
                        try { s.onclose = () => {}; } catch (e) {}
                        try { s.onerror = () => {}; } catch (e) {}
                        s.close();
                    }
                } catch (e) {}
                delete sockets[topic];
            });
        }

                // Compute nearest index on the route for a given lat/lon
                function nearestRouteIndex(lat, lon) {
                    if (!routePoints || routePoints.length === 0) return -1;
                    let bestI = -1;
                    let bestDist = Infinity;
                    for (let i = 0; i < routePoints.length; i++) {
                        const p = routePoints[i];
                        const dx = p[0] - lat;
                        const dy = p[1] - lon;
                        const d2 = dx * dx + dy * dy;
                        if (d2 < bestDist) {
                            bestDist = d2;
                            bestI = i;
                        }
                    }
                    return bestI;
                }

                // Update leaderboard DOM by sorting athletes by progress along route
                function updateLeaderboard() {
                    const list = document.getElementById('leaderboardList');
                    if (!list) return;
                    // Build array of {name, idx}
                    const entries = Object.keys(athleteData).map(name => {
                        const a = athleteData[name];
                        const idx = nearestRouteIndex(a.lat, a.lon);
                        return { name, idx, topic: a.topic };
                    });
                    // Sort descending by idx (higher index = further along)
                    entries.sort((a, b) => b.idx - a.idx);
                    // Build HTML
                    list.innerHTML = '';
                    entries.forEach(e => {
                        const li = document.createElement('li');
                        li.textContent = `${e.name} (${e.topic || ''})`;
                        list.appendChild(li);
                    });
                }

                // Periodically refresh leaderboard in case of gaps
                setInterval(updateLeaderboard, 1000);

    // --- Topic selection ---
    const topicSelect = document.getElementById("topicSelect");
    function topicToGpxFile(selectedTopic) {
        // Map a topic name to an existing GPX file under /gpx
        // If the selectedTopic looks like 'trail_<name>' we use that name.
        if (!selectedTopic) return 'gpx/trail_route_1.gpx';
        if (selectedTopic.startsWith('trail_')) {
            // topic 'trail_route_1' maps directly to gpx/trail_route_1.gpx
            return `gpx/${selectedTopic}.gpx`;
        }
        // Known legacy topics -> map to a default GPX
        const FALLBACK_MAP = {
            'runner-events': 'gpx/trail_route_1.gpx'
        };
        return FALLBACK_MAP[selectedTopic] || 'gpx/trail_route_1.gpx';
    }        topicSelect.addEventListener("change", (e) => {
            const selectedTopic = e.target.value;
            console.log("Switching to topic:", selectedTopic);
            // Close any existing sockets first (prevent new incoming messages)
            closeAllSockets();

            // Clear existing markers and leaderboard when switching topics
            clearMarkers();

            if (selectedTopic === 'all') {
                // Open sockets for every trail topic found in the select
                const topicOptions = [];
                for (const opt of topicSelect.options) {
                    const v = opt.value;
                    if (v && v.startsWith('trail_')) {
                        topicOptions.push(v);
                    }
                }

                // open sockets and load GPX for each topic with a distinct color
                clearGpxLayers();
                for (let i = 0; i < topicOptions.length; i++) {
                    const v = topicOptions[i];
                    connectWebSocket(v);
                    const gpxFile = topicToGpxFile(v);
                    loadGPX(gpxFile, v, getColorForTopic(v));
                }
                return;
            }

            connectWebSocket(selectedTopic);

            // Load corresponding GPX (map legacy topics to a default GPX)
            clearGpxLayers();
            const gpxFile = topicToGpxFile(selectedTopic);
            loadGPX(gpxFile, selectedTopic, getColorForTopic(selectedTopic));
        });

        // Initialize first connection using the current select value
        const initialTopic = topicSelect.value;
        if (initialTopic === 'all') {
            // connect to all topics and load their GPX layers
            const topicOptions = [];
                for (const opt of topicSelect.options) {
                const v = opt.value;
                if (v && v.startsWith('trail_')) topicOptions.push(v);
            }
            for (const v of topicOptions) {
                connectWebSocket(v);
                const gpxFile = topicToGpxFile(v);
                loadGPX(gpxFile, v, getColorForTopic(v));
            }
        } else {
            connectWebSocket(initialTopic);
            loadGPX(topicToGpxFile(initialTopic), initialTopic, getColorForTopic(initialTopic));
        }
    </script>
</body>
</html>
